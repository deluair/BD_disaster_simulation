"""
VulnerabilityModel: Models vulnerability of different exposure elements to hazards
"""

import numpy as np

class VulnerabilityModel:
    """Model vulnerability of different exposure elements to hazards"""
    def __init__(self):
        # Initialize vulnerability curves and damage functions
        self._initialize_vulnerability_functions()
    
    def _initialize_vulnerability_functions(self):
        """Initialize vulnerability functions for different elements and hazards"""
        # Building damage functions by building type and hazard
        self.building_vulnerability = {
            # Flood vulnerability functions - maps depth (m) to damage ratio
            'flood': {
                'RCC': {
                    'damage_function': lambda depth: min(0.9, max(0, 0.1 * depth ** 1.25)),
                    'threshold': 0.3,  # Damage begins at 0.3m depth
                    'collapse_threshold': 3.0  # Potential collapse at 3m depth
                },
                'semi_pucca': {
                    'damage_function': lambda depth: min(0.95, max(0, 0.2 * depth ** 1.5)),
                    'threshold': 0.2,
                    'collapse_threshold': 2.5
                },
                'kutcha': {
                    'damage_function': lambda depth: min(1.0, max(0, 0.3 * depth ** 1.7)),
                    'threshold': 0.1,
                    'collapse_threshold': 2.0
                },
                'jhupri': {
                    'damage_function': lambda depth: min(1.0, max(0, 0.5 * depth ** 2.0)),
                    'threshold': 0.05,
                    'collapse_threshold': 1.5
                }
            },
            # Cyclone vulnerability functions - maps wind speed (km/h) to damage ratio
            'cyclone': {
                'RCC': {
                    'damage_function': lambda wind: min(0.9, max(0, 0.0001 * (wind - 80) ** 2 if wind > 80 else 0)),
                    'threshold': 80,  # Damage begins at 80 km/h
                    'collapse_threshold': 250  # Potential collapse at 250 km/h
                },
                'semi_pucca': {
                    'damage_function': lambda wind: min(0.95, max(0, 0.0002 * (wind - 60) ** 2 if wind > 60 else 0)),
                    'threshold': 60,
                    'collapse_threshold': 200
                },
                'kutcha': {
                    'damage_function': lambda wind: min(1.0, max(0, 0.0004 * (wind - 40) ** 2 if wind > 40 else 0)),
                    'threshold': 40,
                    'collapse_threshold': 150
                },
                'jhupri': {
                    'damage_function': lambda wind: min(1.0, max(0, 0.0008 * (wind - 30) ** 2 if wind > 30 else 0)),
                    'threshold': 30,
                    'collapse_threshold': 120
                }
            },
            # Earthquake vulnerability functions - maps PGA (g) to damage ratio
            'earthquake': {
                'RCC': {
                    'damage_function': lambda pga: min(0.9, max(0, 1.5 * pga ** 1.8)),
                    'threshold': 0.1,  # Damage begins at 0.1g
                    'collapse_threshold': 0.6  # Potential collapse at 0.6g
                },
                'semi_pucca': {
                    'damage_function': lambda pga: min(0.95, max(0, 2.0 * pga ** 1.5)),
                    'threshold': 0.08,
                    'collapse_threshold': 0.4
                },
                'kutcha': {
                    'damage_function': lambda pga: min(1.0, max(0, 2.5 * pga ** 1.3)),
                    'threshold': 0.05,
                    'collapse_threshold': 0.3
                },
                'jhupri': {
                    'damage_function': lambda pga: min(1.0, max(0, 3.0 * pga ** 1.2)),
                    'threshold': 0.03,
                    'collapse_threshold': 0.2
                }
            }
        }
        
        # Critical infrastructure vulnerability functions
        self.infrastructure_vulnerability = {
            # Hospital vulnerability to different hazards
            'hospitals': {
                'flood': lambda depth: min(0.8, max(0, 0.15 * depth ** 1.3)),
                'cyclone': lambda wind: min(0.7, max(0, 0.00007 * (wind - 100) ** 2 if wind > 100 else 0)),
                'earthquake': lambda pga: min(0.9, max(0, 1.3 * pga ** 1.7))
            },
            # Schools vulnerability
            'schools': {
                'flood': lambda depth: min(0.9, max(0, 0.2 * depth ** 1.5)),
                'cyclone': lambda wind: min(0.8, max(0, 0.00009 * (wind - 80) ** 2 if wind > 80 else 0)),
                'earthquake': lambda pga: min(0.95, max(0, 1.8 * pga ** 1.5))
            },
            # Bridge vulnerability
            'bridges': {
                'flood': lambda depth: min(0.7, max(0, 0.05 * depth ** 2.5)),  # Scour damage
                'cyclone': lambda wind: min(0.4, max(0, 0.00003 * (wind - 120) ** 2 if wind > 120 else 0)),
                'earthquake': lambda pga: min(0.85, max(0, 1.2 * pga ** 1.8))
            },
            # Embankment vulnerability
            'embankments': {
                'flood': lambda depth: min(1.0, max(0, 0.1 * depth ** 2.2)),
                'cyclone': lambda wind: min(0.6, max(0, 0.00004 * wind ** 1.5)),  # Wave action
                'earthquake': lambda pga: min(0.7, max(0, 1.0 * pga ** 1.6))  # Liquefaction
            },
            # Power infrastructure vulnerability
            'power_infrastructure': {
                'flood': lambda depth: min(0.95, max(0, 0.25 * depth ** 1.2)),
                'cyclone': lambda wind: min(0.9, max(0, 0.0001 * (wind - 60) ** 2 if wind > 60 else 0)),
                'earthquake': lambda pga: min(0.8, max(0, 1.3 * pga ** 1.4))
            },
            # Telecom infrastructure vulnerability
            'telecom': {
                'flood': lambda depth: min(0.9, max(0, 0.2 * depth ** 1.3)),
                'cyclone': lambda wind: min(0.95, max(0, 0.00015 * (wind - 70) ** 2 if wind > 70 else 0)),
                'earthquake': lambda pga: min(0.75, max(0, 1.1 * pga ** 1.5))
            }
        }
        
        # Agricultural vulnerability by crop type and hazard
        self.agricultural_vulnerability = {
            'rice': {
                'flood': lambda depth, duration: min(1.0, max(0, (0.2 * depth + 0.05 * duration))),
                'cyclone': lambda wind: min(1.0, max(0, 0.003 * wind - 0.15 if wind > 50 else 0)),
                'drought': lambda severity: min(1.0, max(0, 0.8 * severity))
            },
            'wheat': {
                'flood': lambda depth, duration: min(1.0, max(0, (0.3 * depth + 0.07 * duration))),
                'cyclone': lambda wind: min(1.0, max(0, 0.0025 * wind - 0.1 if wind > 40 else 0)),
                'drought': lambda severity: min(1.0, max(0, 0.7 * severity))
            },
            'jute': {
                'flood': lambda depth, duration: min(1.0, max(0, (0.15 * depth + 0.04 * duration))),
                'cyclone': lambda wind: min(1.0, max(0, 0.0035 * wind - 0.12 if wind > 45 else 0)),
                'drought': lambda severity: min(1.0, max(0, 0.9 * severity))
            },
            'vegetables': {
                'flood': lambda depth, duration: min(1.0, max(0, (0.35 * depth + 0.08 * duration))),
                'cyclone': lambda wind: min(1.0, max(0, 0.004 * wind - 0.1 if wind > 35 else 0)),
                'drought': lambda severity: min(1.0, max(0, 0.85 * severity))
            },
            'aquaculture': {
                'flood': lambda depth, duration: min(1.0, max(0, (0.1 * depth + 0.02 * duration))),  # Flooding can be less damaging for aquaculture
                'cyclone': lambda wind: min(1.0, max(0, 0.0015 * wind - 0.05 if wind > 60 else 0)),  # Primarily damage to structures
                'drought': lambda severity: min(1.0, max(0, 0.95 * severity))  # Very sensitive to water availability
            }
        }
        
        # Social vulnerability multipliers
        self.social_vulnerability_multipliers = {
            'poverty': lambda poverty_rate: 1.0 + poverty_rate * 0.5,  # 50% increase at 100% poverty rate
            'gender': {'female': 1.2, 'male': 1.0},  # 20% higher vulnerability for women
            'age': lambda age: 1.3 if age < 14 or age > 65 else 1.0,  # 30% higher for children and elderly
            'disability': 1.5,  # 50% higher for persons with disabilities
            'education': lambda edu_years: max(1.0, 1.4 - 0.03 * edu_years),  # Lower with education
            'social_capital': lambda social_index: max(0.7, 1.5 - social_index)  # Lower with social connections
        }
        
        # Functional vulnerability (duration of disruption in days)
        self.functional_disruption = {
            'hospitals': {
                'low_damage': lambda: max(0, np.random.gamma(shape=2.0, scale=2.0)),
                'medium_damage': lambda: max(0, np.random.gamma(shape=5.0, scale=6.0)),
                'high_damage': lambda: max(0, np.random.gamma(shape=10.0, scale=15.0))
            },
            'schools': {
                'low_damage': lambda: max(0, np.random.gamma(shape=3.0, scale=5.0)),
                'medium_damage': lambda: max(0, np.random.gamma(shape=7.0, scale=7.0)),
                'high_damage': lambda: max(0, np.random.gamma(shape=12.0, scale=15.0))
            },
            'power': {
                'low_damage': lambda: max(0, np.random.gamma(shape=1.0, scale=1.0)),
                'medium_damage': lambda: max(0, np.random.gamma(shape=3.0, scale=2.0)),
                'high_damage': lambda: max(0, np.random.gamma(shape=7.0, scale=5.0))
            },
            'water': {
                'low_damage': lambda: max(0, np.random.gamma(shape=2.0, scale=1.5)),
                'medium_damage': lambda: max(0, np.random.gamma(shape=5.0, scale=3.0)),
                'high_damage': lambda: max(0, np.random.gamma(shape=10.0, scale=6.0))
            },
            'transport': {
                'low_damage': lambda: max(0, np.random.gamma(shape=1.0, scale=2.0)),
                'medium_damage': lambda: max(0, np.random.gamma(shape=4.0, scale=5.0)),
                'high_damage': lambda: max(0, np.random.gamma(shape=8.0, scale=10.0))
            },
            'telecom': {
                'low_damage': lambda: max(0, np.random.gamma(shape=1.0, scale=1.0)),
                'medium_damage': lambda: max(0, np.random.gamma(shape=2.0, scale=2.0)),
                'high_damage': lambda: max(0, np.random.gamma(shape=5.0, scale=3.0))
            },
        }
    
    def calculate_damages(self, exposed_elements, hazard_event):
        """Calculate physical and functional damages for exposed elements
        
        Args:
            exposed_elements: Dictionary of exposed elements from ExposureModel
            hazard_event: Hazard event properties including type and intensity
            
        Returns:
            Dictionary of damages by element type
        """
        damages = {
            'buildings': {},
            'casualties': {
                'deaths': 0,
                'injuries': 0,
                'displaced': 0
            },
            'infrastructure': {},
            'agriculture': {},
            'economic': {
                'direct_losses': 0,
                'indirect_losses': 0
            },
            'functional_disruption': {}
        }
        
        hazard_type = hazard_event['type']
        
        # Get hazard intensity parameters
        if hazard_type == 'flood':
            intensity = hazard_event['depth']  # Water depth in meters
            duration = hazard_event.get('duration', 3)  # Duration in days, default 3
        elif hazard_type == 'cyclone':
            intensity = hazard_event['wind_speed']  # Wind speed in km/h
            storm_surge = hazard_event.get('storm_surge', 0)  # Storm surge height in meters
        elif hazard_type == 'earthquake':
            intensity = hazard_event['magnitude'] / 10  # Approximate PGA from magnitude
        else:
            # Default generic intensity scaling
            intensity = hazard_event['intensity']
        
        # 1. Calculate building damages
        for building_type, count in exposed_elements['buildings'].items():
            if hazard_type in self.building_vulnerability and building_type in self.building_vulnerability[hazard_type]:
                damage_function = self.building_vulnerability[hazard_type][building_type]['damage_function']
                damage_ratio = damage_function(intensity)
                damages['buildings'][building_type] = {
                    'count': count,
                    'damage_ratio': damage_ratio,
                    'damaged_count': int(count * damage_ratio)
                }
        
        # 2. Calculate casualties based on building damage and time of day
        total_damaged_buildings = sum(d['damaged_count'] for d in damages['buildings'].values())
        total_buildings = sum(exposed_elements['buildings'].values())
        if total_buildings > 0:
            overall_damage_ratio = total_damaged_buildings / total_buildings
            
            # Casualty calculation depends on hazard type and population density
            if hazard_type == 'flood':
                # Slower onset allows evacuation if warning is available
                fatality_rate = 0.0001 + 0.001 * intensity ** 2
                injury_rate = 0.001 + 0.005 * intensity ** 1.5
                displacement_rate = 0.01 + 0.1 * intensity
            elif hazard_type == 'cyclone':
                # Depends on wind speed and if there's a storm surge
                fatality_rate = 0.0001 * (intensity / 100) ** 2
                if 'storm_surge' in hazard_event:
                    fatality_rate += 0.001 * hazard_event['storm_surge'] ** 2
                injury_rate = 0.001 * (intensity / 80) ** 1.8
                displacement_rate = 0.005 * (intensity / 60) ** 1.5
            elif hazard_type == 'earthquake':
                # Building collapse is primary cause of casualties
                fatality_rate = 0.001 * intensity ** 2.5 * overall_damage_ratio
                injury_rate = 0.01 * intensity ** 2 * overall_damage_ratio
                displacement_rate = 0.05 * intensity ** 1.5 * overall_damage_ratio
            else:
                # Generic hazard
                fatality_rate = 0.0001 * intensity * overall_damage_ratio
                injury_rate = 0.001 * intensity * overall_damage_ratio
                displacement_rate = 0.01 * intensity * overall_damage_ratio
            
            # Calculate casualties
            damages['casualties']['deaths'] = int(exposed_elements['population'] * fatality_rate)
            damages['casualties']['injuries'] = int(exposed_elements['population'] * injury_rate)
            damages['casualties']['displaced'] = int(exposed_elements['population'] * displacement_rate)
        
        # 3. Calculate infrastructure damages
        for infra_type, count in exposed_elements['critical_infrastructure'].items():
            # Map the infrastructure types to our vulnerability categories
            vulnerability_key = None
            if 'hospital' in infra_type:
                vulnerability_key = 'hospitals'
            elif 'school' in infra_type:
                vulnerability_key = 'schools'
            elif 'bridge' in infra_type:
                vulnerability_key = 'bridges'
            elif 'embankment' in infra_type:
                vulnerability_key = 'embankments'
            elif 'power' in infra_type:
                vulnerability_key = 'power_infrastructure'
            elif 'telecom' in infra_type:
                vulnerability_key = 'telecom'
            
            if vulnerability_key and vulnerability_key in self.infrastructure_vulnerability:
                if hazard_type in self.infrastructure_vulnerability[vulnerability_key]:
                    damage_function = self.infrastructure_vulnerability[vulnerability_key][hazard_type]
                    damage_ratio = damage_function(intensity)
                    damages['infrastructure'][infra_type] = {
                        'count': count,
                        'damage_ratio': damage_ratio,
                        'damaged_count': int(count * damage_ratio)
                    }
                    
                    # Calculate functional disruption
                    if vulnerability_key in self.functional_disruption:
                        if damage_ratio < 0.2:
                            disruption_days = self.functional_disruption[vulnerability_key]['low_damage']()
                        elif damage_ratio < 0.5:
                            disruption_days = self.functional_disruption[vulnerability_key]['medium_damage']()
                        else:
                            disruption_days = self.functional_disruption[vulnerability_key]['high_damage']()
                        
                        damages['functional_disruption'][infra_type] = {
                            'mean_disruption_days': disruption_days,
                            'total_service_days_lost': int(count * damage_ratio * disruption_days)
                        }
        
        # 4. Calculate agricultural damages
        for crop_type, area in exposed_elements['agriculture'].items():
            # Map crop type to our vulnerability categories
            vulnerability_key = None
            if 'rice' in crop_type:
                vulnerability_key = 'rice'
            elif 'wheat' in crop_type:
                vulnerability_key = 'wheat'
            elif 'jute' in crop_type:
                vulnerability_key = 'jute'
            elif 'vegetable' in crop_type:
                vulnerability_key = 'vegetables'
            elif 'aquaculture' in crop_type:
                vulnerability_key = 'aquaculture'
            else:
                vulnerability_key = 'rice'  # Default if no match
            
            if vulnerability_key and vulnerability_key in self.agricultural_vulnerability:
                if hazard_type == 'flood' and 'flood' in self.agricultural_vulnerability[vulnerability_key]:
                    damage_function = self.agricultural_vulnerability[vulnerability_key]['flood']
                    damage_ratio = damage_function(intensity, hazard_event.get('duration', 3))
                elif hazard_type == 'cyclone' and 'cyclone' in self.agricultural_vulnerability[vulnerability_key]:
                    damage_function = self.agricultural_vulnerability[vulnerability_key]['cyclone']
                    damage_ratio = damage_function(intensity)
                elif hazard_type == 'drought' and 'drought' in self.agricultural_vulnerability[vulnerability_key]:
                    damage_function = self.agricultural_vulnerability[vulnerability_key]['drought']
                    damage_ratio = damage_function(intensity)
                else:
                    # Generic damage model
                    damage_ratio = min(0.9, max(0, 0.2 * intensity))
                
                damages['agriculture'][crop_type] = {
                    'area_ha': area,
                    'damage_ratio': damage_ratio,
                    'damaged_area_ha': int(area * damage_ratio)
                }
        
        # 5. Calculate economic losses
        # Direct losses from physical damages
        building_losses = self._calculate_building_losses(damages['buildings'])
        infrastructure_losses = self._calculate_infrastructure_losses(damages['infrastructure'])
        agriculture_losses = self._calculate_agriculture_losses(damages['agriculture'])
        
        damages['economic']['direct_losses'] = building_losses + infrastructure_losses + agriculture_losses
        
        # Indirect losses (simplified as a function of direct losses and functional disruption)
        disruption_factor = sum(d.get('total_service_days_lost', 0) for d in damages['functional_disruption'].values()) / 100
        indirect_loss_multiplier = min(3.0, max(0.2, 0.5 + 0.1 * disruption_factor))
        damages['economic']['indirect_losses'] = damages['economic']['direct_losses'] * indirect_loss_multiplier
        
        return damages
    
    def _calculate_building_losses(self, building_damages):
        """Calculate economic losses from building damages"""
        # Average values in BDT (Bangladesh Taka)
        building_values = {
            'RCC': 5000000,  # 50 lakh per building
            'semi_pucca': 1500000,  # 15 lakh per building
            'kutcha': 500000,  # 5 lakh per building
            'jhupri': 100000,  # 1 lakh per building
        }
        
        total_loss = 0
        for building_type, damage in building_damages.items():
            if building_type in building_values:
                avg_value = building_values[building_type]
                total_loss += damage['damaged_count'] * avg_value * damage['damage_ratio']
        
        return total_loss
    
    def _calculate_infrastructure_losses(self, infrastructure_damages):
        """Calculate economic losses from infrastructure damages"""
        # Average values in BDT (Bangladesh Taka)
        infrastructure_values = {
            'hospitals': 100000000,  # 10 crore per hospital
            'primary_schools': 10000000,  # 1 crore per primary school
            'secondary_schools': 20000000,  # 2 crore per secondary school
            'power_plants': 5000000000,  # 500 crore per power plant
            'bridges': 50000000,  # 5 crore per bridge
            'embankments_km': 10000000,  # 1 crore per km
            'cyclone_shelters': 20000000,  # 2 crore per shelter
            'telecom_towers': 5000000,  # 50 lakh per tower
        }
        
        total_loss = 0
        for infra_type, damage in infrastructure_damages.items():
            value_key = next((key for key in infrastructure_values.keys() if key in infra_type), None)
            if value_key:
                avg_value = infrastructure_values[value_key]
                total_loss += damage['damaged_count'] * avg_value * damage['damage_ratio']
        
        return total_loss
    
    def _calculate_agriculture_losses(self, agriculture_damages):
        """Calculate economic losses from agricultural damages"""
        # Average yield values in BDT per hectare
        agriculture_values = {
            'rice_area_ha': 150000,  # 1.5 lakh per hectare per season
            'wheat_area_ha': 120000,  # 1.2 lakh per hectare per season
            'jute_area_ha': 200000,  # 2 lakh per hectare per season
            'vegetable_area_ha': 300000,  # 3 lakh per hectare per season
            'aquaculture_area_ha': 500000,  # 5 lakh per hectare per season
        }
        
        total_loss = 0
        for crop_type, damage in agriculture_damages.items():
            if crop_type in agriculture_values:
                avg_value = agriculture_values[crop_type]
                total_loss += damage['damaged_area_ha'] * avg_value * damage['damage_ratio']
        
        return total_loss
